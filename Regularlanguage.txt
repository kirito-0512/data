25723,
Regularlanguage,
In theoretical computer science and formal language theory, a regular language (also called a rational language)[1][2] is a formal language that can be defined by a regular expression, in the strict sense in theoretical computer science (as opposed to many modern regular expression engines, which are augmented with features that allow the recognition of non-regular languages).
Alternatively, a regular language can be defined as a language recognized by a finite automaton. The equivalence of regular expressions and finite automata is known as Kleene's theorem[3] (after American mathematician Stephen Cole Kleene). In the Chomsky hierarchy, regular languages are the languages generated by Type-3 grammars.
The collection of regular languages over an alphabet Σ is defined recursively as follows:
See regular expression for syntax and semantics of regular expressions.
All finite languages are regular; in particular the empty string language {ε} = Ø* is regular. Other typical examples include the language consisting of all strings over the alphabet {a, b} which contain an even number of a's, or the language consisting of all strings of the form: several a's followed by several b's.
A simple example of a language that is not regular is the set of strings {anbn | n ≥ 0}.[4] Intuitively, it cannot be recognized with a finite automaton, since a finite automaton has finite memory and it cannot remember the exact number of a's. Techniques to prove this fact rigorously are given below.
A regular language satisfies the following equivalent properties:
Properties 10. and 11. are purely algebraic approaches to define regular languages; a similar set of statements can be formulated for a monoid M ⊆ Σ*. In this case, equivalence over M leads to the concept of a recognizable language.
Some authors use one of the above properties different from "1." as an alternative definition of regular languages.
Some of the equivalences above, particularly those among the first four formalisms, are called Kleene's theorem in textbooks. Precisely which one (or which subset) is called such varies between authors. One textbook calls the equivalence of regular expressions and NFAs ("1." and "2." above) "Kleene's theorem".[6] Another textbook calls the equivalence of regular expressions and DFAs ("1." and "3." above) "Kleene's theorem".[7] Two other textbooks first prove the expressive equivalence of NFAs and DFAs ("2." and "3.") and then state "Kleene's theorem" as the equivalence between regular expressions and finite automata (the latter said to describe "recognizable languages").[2][8] A linguistically oriented text first equates regular grammars ("4." above) with DFAs and NFAs, calls the languages generated by (any of) these "regular", after which it introduces regular expressions which it terms to describe "rational languages", and finally states "Kleene's theorem" as the coincidence of regular and rational languages.[9] Other authors simply define "rational expression" and "regular expressions" as synonymous and do the same with "rational languages" and "regular languages".[1][2]
Apparently, the term "regular" originates from a 1951 technical report where Kleene introduced "regular events" and explicitly welcomed "any suggestions as to a more descriptive term".[10] Noam Chomsky, in his 1959 seminal article, used the term "regular" in a different meaning at first (referring to what is called "Chomsky normal form" today),[11] but noticed that his "finite state languages" were equivalent to Kleene's "regular events".[12]
The regular languages are closed under various operations, that is, if the languages K and L are regular, so is the result of the following operations:
Given two deterministic finite automata A and B, it is decidable whether they accept the same language.[16]
As a consequence, using the above closure properties, the following problems are also decidable for arbitrarily given deterministic finite automata A and B, with accepted languages LA and LB, respectively:
For regular expressions, the universality problem is NP-complete already for a singleton alphabet.[17]
For larger alphabets, that problem is PSPACE-complete.[18] If regular expressions are extended to allow also a squaring operator, with "A2" denoting the same as "AA", still just regular languages can be described, but the universality problem has an exponential space lower bound,[19][20][21] and is in fact complete for exponential space with respect to polynomial-time reduction.[22]
For a fixed finite alphabet, the theory of the set of all languages — together with strings, membership of a string in a language, and for each character, a function to append the character to a string (and no other operations) — is decidable, and its minimal elementary substructure consists precisely of regular languages.  For a binary alphabet, the theory is called S2S.[23]
In computational complexity theory, the complexity class of all regular languages is sometimes referred to as REGULAR or REG and equals DSPACE(O(1)), the decision problems that can be solved in constant space (the space used is independent of the input size). REGULAR ≠ AC0, since it (trivially) contains the parity problem of determining whether the number of 1 bits in the input is even or odd and this problem is not in AC0.[24] On the other hand, REGULAR does not contain AC0, because the nonregular language of palindromes, or the nonregular language 



{

0

n



1

n


:
n
∈

N

}


{\displaystyle \{0^{n}1^{n}:n\in \mathbb {N} \}}

 can both be recognized in AC0.[25]
If a language is not regular, it requires a machine with at least Ω(log log n) space to recognize (where n is the input size).[26] In other words, DSPACE(o(log log n)) equals the class of regular languages. In practice, most nonregular problems are solved by machines taking at least logarithmic space.
To locate the regular languages in the Chomsky hierarchy, one notices that every regular language is context-free. The converse is not true: for example, the language consisting of all strings having the same number of a's as b's is context-free but not regular. To prove that a language is not regular, one often uses the Myhill–Nerode theorem and the pumping lemma. Other approaches include using the closure properties of regular languages[27] or quantifying Kolmogorov complexity.[28]
Important subclasses of regular languages include
Let 




s

L


(
n
)


{\displaystyle s_{L}(n)}

 denote the number of words of length 



n


{\displaystyle n}

 in 



L


{\displaystyle L}

.  The ordinary generating function for L is the formal power series
The generating function of a language L is a rational function if L is regular.[31]  Hence for every regular language 



L


{\displaystyle L}

 the sequence 




s

L


(
n

)

n
≥
0




{\displaystyle s_{L}(n)_{n\geq 0}}

 is constant-recursive; that is, there exist an integer constant 




n

0




{\displaystyle n_{0}}

, complex constants 




λ

1


,

…
,


λ

k




{\displaystyle \lambda _{1},\,\ldots ,\,\lambda _{k}}

 and complex polynomials 




p

1


(
x
)
,

…
,


p

k


(
x
)


{\displaystyle p_{1}(x),\,\ldots ,\,p_{k}(x)}


such that for every 



n
≥

n

0




{\displaystyle n\geq n_{0}}

 the number 




s

L


(
n
)


{\displaystyle s_{L}(n)}

 of words of length 



n


{\displaystyle n}

 in 



L


{\displaystyle L}

 is





s

L


(
n
)
=

p

1


(
n
)

λ

1


n


+
⋯
+

p

k


(
n
)

λ

k


n




{\displaystyle s_{L}(n)=p_{1}(n)\lambda _{1}^{n}+\dotsb +p_{k}(n)\lambda _{k}^{n}}

.[32][33][34][35]
Thus, non-regularity of certain languages 




L
′



{\displaystyle L'}

 can be proved by counting the words of a given length in





L
′



{\displaystyle L'}

. Consider, for example, the Dyck language of strings of balanced parentheses. The number of words of length 



2
n


{\displaystyle 2n}


in the Dyck language is equal to the Catalan number 




C

n


∼



4

n




n

3

/

2




π







{\displaystyle C_{n}\sim {\frac {4^{n}}{n^{3/2}{\sqrt {\pi }}}}}

, which is not of the form 



p
(
n
)

λ

n




{\displaystyle p(n)\lambda ^{n}}

,
witnessing the non-regularity of the Dyck language. Care must be taken since some of the eigenvalues 




λ

i




{\displaystyle \lambda _{i}}

 could have the same magnitude. For example, the number of words of length 



n


{\displaystyle n}

 in the language of all even binary words is not of the form 



p
(
n
)

λ

n




{\displaystyle p(n)\lambda ^{n}}

, but the number of words of even or odd length are of this form; the corresponding eigenvalues are 



2
,
−
2


{\displaystyle 2,-2}

. In general, for every regular language there exists a constant 



d


{\displaystyle d}

 such that for all 



a


{\displaystyle a}

, the number of words of length 



d
m
+
a


{\displaystyle dm+a}

 is asymptotically 




C

a



m


p

a





λ

a


m




{\displaystyle C_{a}m^{p_{a}}\lambda _{a}^{m}}

.[36]
The zeta function of a language L is[31]
The zeta function of a regular language is not in general rational, but that of an arbitrary cyclic language is.[37][38]
The notion of a regular language has been generalized to infinite words (see ω-automata) and to trees (see tree automaton).
Rational set generalizes the notion (of regular/rational language) to monoids that are not necessarily free. Likewise, the notion of a recognizable language (by a finite automaton) has namesake as recognizable set over a monoid that is not necessarily free. Howard Straubing notes in relation to these facts that “The term "regular language" is a bit unfortunate. Papers influenced by Eilenberg's monograph[39] often use either the term "recognizable language", which refers to the behavior of automata, or "rational language", which refers to important analogies between regular expressions and rational power series. (In fact, Eilenberg defines rational and recognizable subsets of arbitrary monoids; the two notions do not, in general, coincide.) This terminology, while better motivated, never really caught on, and "regular language" is used almost universally.”[40]
Rational series is another generalization, this time in the context of a formal power series over a semiring. This approach gives rise to weighted rational expressions and weighted automata. In this algebraic context, the regular languages (corresponding to Boolean-weighted rational expressions) are usually called rational languages.[41][42] Also in this context, Kleene's theorem finds a generalization called the Kleene-Schützenberger theorem.


