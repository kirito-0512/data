39564,
BASIC09,
BASIC09 is a structured BASIC programming language dialect developed by Microware on behalf of Motorola for the then-new Motorola 6809 CPU and released in February 1980.[1] It is primarily used with the OS-9 operating system, released in 1979. Microware also released a version for OS-9/68k on the 68000 as Microware BASIC.[2]
In contrast to typical BASICs of the era, BASIC09 includes a multi-pass compiler that produces compact bytecode known as I-code. I-code replaces a number of data structures found in other BASICs with direct pointers to code and values, speeding performance. Users can further compile code using the PACK command, at which point it can be called directly by OS-9 and operated as native code. In the case of PACKed code, a cut-down version of the BASIC09 runtime system is used, Runb, further improving memory footprint and load time.
The language includes a number of structured programming additions, including local variables, the ability to ignore line numbers in favor of named routines, user-defined structures, and several distinct base data types including 16-bit and 8-bit (byte) integers, in addition to floating point and strings.
A key difference between BASIC09 and conventional BASICs of the era, like the canonical Microsoft BASIC, is the addition of the PROCEDURE structure which created separately executable blocks of code. Code in a PROCEDURE had more in common with complete programs in other BASICs, including the variables being local to the code, and their ability to be executed in a stand-alone fashion. PROCEDUREs were called by name using the RUN command, and could include variables for function-call semantics; for instance, RUN add(4,7) calls a procedure named add that takes two parameters. Parameters were imported into the procedure using the PARAM keyword, in this example PARAM a,b:[3]
A side-effect of the use of named procedures is that the resulting memory workspace is, in effect, its own namespace. In this respect, the BASIC09 system appears to the user to be a directory of callable programs. This contrasts with typical BASICs, where only one program is available at a given time and the construction of larger programs calling library-like code generally requires the source code to be copied and pasted between separate programs. In BASIC09, the user can LOAD procedures by name into the workspace and then call them from their own code to construct larger programs from the separately stored procedures.[4][a]
In addition to code in the workspace, if the program invokes RUN with a procedure name that could not be found, it would then look for a disk file with the same name and load and run that file. This worked not only with BASIC09 code, but also any other executable program, including machine language files. This meant that BASIC09 could easily call system routines.[5]
In addition to RUN, other common BASIC commands likewise used names. For instance, LIST bob would print out the source code ("list") the procedure named "bob", while LIST* prints out all of the procedures currently in memory. The prettyprinted output from LIST could be redirected to a file or a printer with a shell-like notation, e.g. LIST bob >/p. One could also SAVE and LOAD procedures from storage.[6]
In addition to the organizational properties of the PROCEDURE, BASIC09 also included a number of extensions to the  flow control statements found in BASIC to provide more structure. For instance, the IF statement could be used in the traditional IF...THEN format on a single line, or it could be used in a structured multi-line format:[7]
FOR/NEXT loops naturally have a structured format as the NEXT can be placed on any line, but BASIC09 also added WHILE/ENDWHILE and REPEAT/UNTIL for additional clarity when working with non-indexed loops.[8] It also included the center-exit LOOP/ENDLOOP which used the EXITIF statement for testing anywhere in the loop's body.[9]
BASIC09 included several built-in data types. In addition to the traditional string (STRING) and 40-bit floating point (REAL) types found in most BASICs of the era, it also included the 16-bit signed INTEGER, the 8-bit unsigned BYTE, and the logical BOOLEAN type. The BOOLEAN types were not packed into bytes, a single BOOLEAN used an entire 8-bit byte to store a single value. The language provided separate bytewise boolean operators for bitwise operations on BYTEs and INTEGERs.[10] In contrast to other BASICs that also operated different base types, BASIC09 did not "decorate" the variable name to indicate the type, and instead used the DIM for definitions; for instance, DIM a,b:BOOLEAN to declare two BOOLEAN variables, or DIM c(5):INTEGER for an array of five INTEGERs.[11]
Additionally, BASIC09 included the TYPE keyword, which allowed compound types to be defined, with each "element" listed on a single line separated by semicolons. For instance:[12]
defines an employee record type named employee_record with three elements, name, number and former. The employee_record type can now be used in a definition like any other type, for instance, DIM employees(100):employee_record, which defines an array of 100 employee_record's. The elements are accessed in code using dot notation, for instance, employees(50).name="Bob".[12]
Line numbers were used in most BASIC dialects primarily as a way to support the editor. Users would edit particular lines of code by typing a number, with the text following either adding to or replacing the lines already in memory. As every line of code had a number, this also made them suitable for indicating the target of a GOTO or GOSUB, compared to other languages like FORTRAN where a separate "line label" was used for this purpose.
BASIC09 did not normally use line numbers, so its editor had to be modified to allow the user to edit lines without referring to them by number. However, BASIC09 did not assume any sort of full-screen capability, so using cursor keys was not an option. Instead, the system had a separate editor prompt and allowed the user to move about using the + and - keys, moving forward or backward one line at a time. To insert a new line of code without a line number, the user left a blank at the start of the statement.[13]
Note that the language is case sensitive for user-provided values like procedure and variable names, but not for keywords. Keywords typed into the editor in lower case will be shown in upper case when the program is LISTed.[14] BASIC09 allowed multiple statements on a single line of code, but used the \ as a separator instead of the : used in most dialects.[15][b] This is because it used the colon in the := assignment operator, which was in addition to the normal =. := was identical in effect to =, but made the difference between assignments and comparisons more obvious.[16]
The internal multipass compiler converts BASIC09 source code into a tokenized, optimized, bytecode, called I-code.[17] I-code differs from the more traditional tokenizing approach found in most BASICs in that a number of items were placed directly in memory instead of using references that then had to be looked up.[18]
For instance, in MS-based interpreters, a variable reference in code is left in string format; the variable VAR would be represented in memory by the three ASCII characters "VAR". During execution, when this variable is encountered in the code the interpreter has to look up that string in a table of variables, find the associated storage address in memory, and then finally read the value stored in that location. The table is usually constructed so that the value follows the name, to save time during the final lookup.[17]
In contrast, in I-code the address of the variable is determined in advance and the reference in code is replaced by that address. This avoids a runtime search through the variable table.[17] Other optimizations include a separate FOR/NEXT routine used when the index variable is an INTEGER, and separate INTEGER and REAL math libraries.[18][c]
For added performance, BASIC09 also included the PACK command which took a procedure name and returned an optimized version. Some of these optimizations included removing non-coding instructions like code comments and the replacement of constant expressions to a single value. For instance, PACK would recognize that LET x=x+SQR(100)/2 contains only constants on the right, and replaces it with the code x=x+5, which requires only a single operation at runtime, the addition, removing the division and square root. PACK reduced the memory footprint of the procedure and improved performance by about 10 to 30%.[19]
Although it was common to run programs within the BASIC09 environment, as it was in other BASICs, BASIC09 also shipped with a separate run-only version of the code known as Runb. Runb removed the editing and debugging features of the system, and was about half the size of the full BASIC09 as a result.[20]
The purpose of Runb was primarily to run PACKed modules when called from other programs. This meant that if the user typed in the name of a BASIC09 module in the OS/9 command line, and that module has been marked as PACKed, it is opened and run by Runb instead of the BASIC09. This reduces memory footprint and improves load time.[20]
[1][2][3][4]
Information box
{'Designed by': 'Motorola', 'Developer': 'Microware', 'First appeared': '1980; 43 years ago', 'Stable release': '1.1.0 / January 5, 2003; 20 years ago'}
