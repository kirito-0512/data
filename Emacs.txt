10471,
Emacs,
Emacs /ˈiːmæks/, originally named EMACS (an acronym for "Editor MACroS"),[4][5][6] is a family of text editors that are characterized by their extensibility.[7] The manual for the most widely used variant,[8] GNU Emacs, describes it as "the extensible, customizable, self-documenting, real-time display editor".[9] Development of the first Emacs began in the mid-1970s, and work on its direct descendant, GNU Emacs, continues actively; the latest version is 28.2, released in September 2022.
Emacs has over 10,000 built-in commands and its user interface allows the user to combine these commands into macros to automate work. Implementations of Emacs typically feature a dialect of the Lisp programming language, allowing users and developers to write new commands and applications for the editor. Extensions have been written to, among other things, manage files, remote access,[10] e-mail, outlines, multimedia, Git integration, and RSS feeds,[11] as well as implementations of ELIZA, Pong, Conway's Life, Snake, Dunnet, and Tetris.[12]
The original EMACS was written in 1976 by David A. Moon and Guy L. Steele Jr. as a set of Editor MACroS for the TECO editor.[3][4][5][6][13] It was inspired by the ideas of the TECO-macro editors TECMAC and TMACS.[14]
The most popular, and most ported, version of Emacs is GNU Emacs, which was created by Richard Stallman for the GNU Project.[15] XEmacs is a variant that branched from GNU Emacs in 1991. GNU Emacs and XEmacs use similar Lisp dialects and are, for the most part, compatible with each other. XEmacs development is inactive.
Emacs is, along with vi, one of the two main contenders in the traditional editor wars of Unix culture. Emacs is among the oldest free and open source projects still under development.[16]
Emacs development began during the 1970s at the MIT AI Lab, whose PDP-6 and PDP-10 computers used the Incompatible Timesharing System (ITS) operating system that featured a default line editor known as Tape Editor and Corrector (TECO). Unlike most modern text editors, TECO used separate modes in which the user would either add text, edit existing text, or display the document. One could not place characters directly into a document by typing them into TECO, but would instead enter a character ('i') in the TECO command language telling it to switch to input mode, enter the required characters, during which time the edited text was not displayed on the screen, and finally enter a character (<esc>) to switch the editor back to command mode. (A similar technique was used to allow overtyping.) This behavior is similar to that of the program ed.
By the 1970s, TECO was already an old program, initially released in 1962. Richard Stallman visited the Stanford AI Lab in 1976[18] and saw the lab's E editor, written by Fred Wright.[19] He was impressed by the editor's intuitive WYSIWYG (What You See Is What You Get) behavior, which has since become the default behavior of most modern text editors. He returned to MIT where Carl Mikkelsen, a hacker at the AI Lab, had added to TECO a combined display/editing mode called Control-R that allowed the screen display to be updated each time the user entered a keystroke. Stallman reimplemented this mode to run efficiently and then added a macro feature to the TECO display-editing mode that allowed the user to redefine any keystroke to run a TECO program.[6]
E had another feature that TECO lacked: random-access editing. TECO was a page-sequential editor that was designed for editing paper tape on the PDP-1 at a time when computer memory was generally small due to cost, and it was a feature of TECO that allowed editing on only one page at a time sequentially in the order of the pages in the file. Instead of adopting E's approach of structuring the file for page-random access on disk, Stallman modified TECO to handle large buffers more efficiently and changed its file-management method to read, edit, and write the entire file as a single buffer. Almost all modern editors use this approach.
The new version of TECO quickly became popular at the AI Lab and soon accumulated a large collection of custom macros whose names often ended in MAC or MACS, which stood for macro. Two years later, Guy Steele took on the project of unifying the diverse macros into a single set.[20] Steele and Stallman's finished implementation included facilities for extending and documenting the new macro set.[6] The resulting system was called EMACS, which stood for Editing MACroS or, alternatively, E with MACroS. Stallman picked the name Emacs "because <E> was not in use as an abbreviation on ITS at the time."[21] An apocryphal hacker koan alleges that the program was named after Emack & Bolio's, a popular Boston ice cream store.[22] The first operational EMACS system existed in late 1976.[23]
Stallman saw a problem in too much customization and de facto forking and set certain conditions for usage.[citation needed] He later wrote:[23]
EMACS was distributed on a basis of communal sharing, which means all improvements must be given back to me to be incorporated and distributed.The original Emacs, like TECO, ran only on the PDP-10 running ITS. Its behavior was sufficiently different from that of TECO that it could be considered a text editor in its own right, and it quickly became the standard editing program on ITS. Mike McMahon ported Emacs from ITS to the TENEX and TOPS-20 operating systems. Other contributors to early versions of Emacs include Kent Pitman, Earl Killian, and Eugene Ciccarelli. By 1979, Emacs was the main editor used in MIT's AI lab and its Laboratory for Computer Science.[24]
In the following years, programmers wrote a variety of Emacs-like editors for other computer systems. These included EINE (EINE Is Not EMACS) and ZWEI[25] (ZWEI Was EINE Initially), which were written for the Lisp machine by Mike McMahon and Daniel Weinreb, and Sine (Sine Is Not Eine),[26] which was written by Owen Theodore Anderson. Weinreb's EINE was the first Emacs written in Lisp. In 1978, Bernard Greenberg wrote Multics Emacs almost entirely in Multics Lisp at Honeywell's Cambridge Information Systems Lab. Multics Emacs was later maintained by Richard Soley, who went on to develop the NILE Emacs-like editor for the NIL Project, and by Barry Margolin. Many versions of Emacs, including GNU Emacs, would later adopt Lisp as an extension language.
James Gosling, who would later invent NeWS and the Java programming language, wrote Gosling Emacs in 1981. The first Emacs-like editor to run on Unix[citation needed], Gosling Emacs was written in C and used Mocklisp, a language with Lisp-like syntax, as an extension language.
Early Ads for Computer Corporation of America's CCA EMACS (Steve Zimmerman).[27] appeared in 1984.[28] 1985 comparisons to GNU Emacs, when it came out, mentioned free vs. $2,400.[29][irrelevant citation]
Richard Stallman began work on GNU Emacs in 1984 to produce a free software alternative to the proprietary Gosling Emacs. GNU Emacs was initially based on Gosling Emacs, but Stallman's replacement of its Mocklisp interpreter with a true Lisp interpreter required that nearly all of its code be rewritten. This became the first program released by the nascent GNU Project. GNU Emacs is written in C and provides Emacs Lisp, also implemented in C, as an extension language. Version 13, the first public release, was made on March 20, 1985. The first widely distributed version of GNU Emacs was version 15.34, released later in 1985. Early versions of GNU Emacs were numbered as 1.x.x, with the initial digit denoting the version of the C core. The 1 was dropped after version 1.12, as it was thought that the major number would never change, and thus the numbering skipped from 1 to 13.[30] In September 2014, it was announced on the GNU emacs-devel mailing list that GNU Emacs would adopt a rapid release strategy and version numbers would increment more quickly in the future.[31]
GNU Emacs offered more features than Gosling Emacs, in particular a full-featured Lisp as its extension language, and soon replaced Gosling Emacs as the de facto Unix Emacs editor. Markus Hess exploited a security flaw in GNU Emacs' email subsystem in his 1986 cracking spree in which he gained superuser access to Unix computers.[32]
Most of GNU Emacs functionality is implemented through a scripting language called Emacs Lisp. Because about 70% of GNU Emacs is written in the Emacs Lisp extension language,[33] one only needs to port the C core which implements the Emacs Lisp interpreter. This makes porting Emacs to a new platform considerably less difficult than porting an equivalent project consisting of native code only.
GNU Emacs development was relatively closed until 1999 and was used as an example of the Cathedral development style in The Cathedral and the Bazaar. The project has since adopted a public development mailing list and anonymous CVS access. Development took place in a single CVS trunk until 2008 and was then switched to the Bazaar DVCS. On November 11, 2014, development was moved to Git.[34]
Richard Stallman has remained the principal maintainer of GNU Emacs, but he has stepped back from the role at times. Stefan Monnier and Chong Yidong were maintainers from 2008 to 2015.[35][36] John Wiegley was named maintainer in 2015 after a meeting with Stallman at MIT.[37] As of early 2014, GNU Emacs has had 579 individual committers throughout its history.[38]
Lucid Emacs, based on an early alpha version of GNU Emacs 19, was developed beginning in 1991 by Jamie Zawinski and others at Lucid Inc. One of the best-known early forks in free software development occurred when the codebases of the two Emacs versions diverged and the separate development teams ceased efforts to merge them back into a single program.[39] Lucid Emacs has since been renamed XEmacs. Its development is currently inactive, with the most recent stable version 21.4.22 released in January 2009 (while a beta was released in 2013), while GNU Emacs has implemented many formerly XEmacs-only features.[40][better source needed]
Other notable forks include:
In the past, projects aimed at producing small versions of Emacs proliferated. GNU Emacs was initially targeted at computers with a 32-bit flat address space and at least 1 MiB of RAM.[42] Such computers were high end workstations and minicomputers in the 1980s, and this left a need for smaller reimplementations that would run on common personal computer hardware. Today's computers have more than enough power and capacity to eliminate these restrictions, but small clones have more recently been designed to fit on software installation disks or for use on less capable hardware.[43]
Other projects aim to implement Emacs in a different dialect of Lisp or a different programming language altogether. Although not all are still actively maintained, these clones include:
Emacs is primarily a text editor and is designed for manipulating pieces of text, although it is capable of formatting and printing documents like a word processor by interfacing with external programs such as LaTeX, Ghostscript or a web browser. Emacs provides commands to manipulate and differentially display semantic units of text such as words, sentences, paragraphs and source code constructs such as functions. It also features keyboard macros for performing user-defined batches of editing commands.
GNU Emacs is a real-time display editor, as its edits are displayed onscreen as they occur. This is standard behavior for modern text editors but EMACS was among the earliest to implement this. The alternative is having to issue a distinct command to display text, (e.g. before or after modifying it). This was common in earlier (or merely simpler) line and context editors, such as QED (BTS, CTSS, Multics), ed (Unix), ED (CP/M), and Edlin (DOS).
Almost all of the functionality in Emacs, including basic editing operations such as the insertion of characters into a file, is achieved through functions written in a dialect of the Lisp programming language. The dialect used in GNU Emacs is known as Emacs Lisp (Elisp), and was developed expressly to port Emacs to GNU and Unix. The Emacs Lisp layer sits atop a stable core of basic services and platform abstraction written in the C programming language, which enables GNU Emacs to be ported to a wide variety of operating systems and architectures without modifying the implementation semantics of the Lisp system where most of the editor lives. In this Lisp environment, variables and functions can be modified with no need to rebuild or restart Emacs, with even newly redefined versions of core editor features being asynchronously compiled and loaded into the live environment to replace existing definitions. Modern GNU Emacs features both bytecode and native code compilation for Emacs Lisp.
All configuration is stored in variables, classes, and data structures, and changed by simply updating these live. The use of a Lisp dialect in this case is a key advantage, as Lisp syntax consists of so-called symbolic expressions (or sexprs), which can act as both evaluatable code expressions and as a data serialisation format akin to, but simpler and more general than, well known ones such as XML, JSON, and YAML. In this way there is little difference in practice between customising existing features and writing new ones, both of which are accomplished in the same basic way. This is operatively different from most modern extensible editors, for instance such as VS Code, in which separate languages are used to implement the interface and features of the editor and to encode its user-defined configuration and options. The goal of Emacs' open design is to transparently expose Emacs' internals to the Emacs user during normal use in the same way that they would be exposed to the Emacs developer working on the git tree, and to collapse as much as possible of the distinction between using Emacs and programming Emacs, while still providing a stable, practical, and responsive editing environment for novice users.
The main text editing data structure is the buffer, a memory region containing data (usually text) with associated attributes. The most important of these are:
Modes, in particular, are an important concept in Emacs, providing a mechanism to disaggregate Emacs' functionality into sets of behaviours and keybinds relevant to specific buffers' data. Major modes provide a general package of functions and commands relevant to a buffer's data and the way users might be interacting with it (e.g. editing source code in a specific language, editing hex, viewing the filesystem, interacting with git, etc.), and minor modes define subsidiary collections of functionality applicable across many major modes (such as auto-save-mode). Minor modes can be toggled on or off both locally to each buffer as well as globally across all buffers, while major modes can only be toggled per-buffer. Any other data relevant to a buffer but not bundled into a mode can be handled by simply focussing that buffer and live modifying the relevant data directly.
Any interaction with the editor (like key presses or clicking a mouse button) is realized by evaluating Emacs Lisp code, typically a command, which is a function explicitly designed for interactive use. Keys can be arbitrarily redefined and commands can also be accessed by name; some commands evaluate arbitrary Emacs Lisp code provided by the user in various ways (e.g. a family of eval- functions, operating on the buffer, region, or individual expression). Even the simplest user inputs (such a printable characters) are effectuated as Emacs Lisp functions, such as the self-insert-command , bound by default to most keyboard keys in a typical text editing buffer, which parameterises itself with the locale-defined character associated with the key used to call it. 
For example, pressing the f key in a buffer that accepts text input evaluates the code (self-insert-command 1 ?f), which inserts one copy of the character constant ?f at point. The 1, in this case, is determined by what Emacs terms the universal argument: all Emacs command code accepts a numeric value which, in its simplest usage, indicates repetition of an action, but in more complex cases (where repetition doesn't make sense) can yield other behaviours. These arguments may be supplied via command prefices, such as Control+u 7 f, or more compactly Meta+7 f, which expands to (self-insert-command 7 ?f). When no prefix is supplied, the universal argument is 1: every command implicitly runs once, but may be called multiply, or in a different way, when supplied with such a prefix. Such arguments may also be non-positive where it makes sense for them to be so - it is up to the function accepting the argument to determine, according to its own semantics, what a given number means to it. One common usage is for functions to perform actions in reverse simply by checking the sign of the univeral argument, such as a sort command which sorts in obverse by default and in reverse when called with a negative argument, using the absolute value of its argument as the sorting key (e.g. -7 sorting in reverse by column index (or delimiter) 7), or undo/redo, which are simply negatives of each other (traversing forward and backward through a recursive history of diffs by some number of steps at a time).
Because of its relatively large vocabulary of commands, Emacs features a long-established command language, to concisely express the keystrokes necessary to perform an action. This command language recognises the following shift and modifier keys: Ctrl, Alt, ⇧ Shift, Meta, Super, and Hyper. Not all of these may be present on an IBM-style keyboard, though they can usually be configured as desired. These are represented in command language as the respective prefices: C-, A-, S-, M-, s-, and H-. Keys whose names are only printable with more than one character are enclosed in angle brackets. Thus, a keyboard shortcut such as Ctrl+Alt+⇧ Shift+F9 (check dependent formulas and calculate all cells in all open workbooks in Excel) would be rendered in Emacs command language as C-A-S-<f9>, while an Emacs command like Meta+s f Ctrl+Meta+s (incremental file search by filename-matching regexp), would be expressed as M-s f C-M-s. Command language is also used to express the actions needed to invoke commands with no assigned shortcut: for example, the command scratch-buffer (which initialises a buffer in memory for temporary text storage and manipulation), when invoked by the user, will be reported back as M-x scra <return>, with Emacs scanning the namespace of contextually available commands to return the shortest sequence of keystrokes which uniquely lexicate it.
Because Emacs predates modern standard terminology for graphical user interfaces, it uses somewhat divergent names for familiar interface elements. Buffers, the data that Emacs users interact with, are displayed to the user inside windows, which are tiled portions of the terminal screen or the GUI window, which Emacs refers to as frames; in modern terminology, an Emacs frame would be a window and an Emacs window would be a split. Depending on configuration, windows can include their own scroll bars, line numbers, sometimes a 'header line' typically to ease navigation, and a mode line at the bottom (usually displaying buffer name, the active modes and point position of the buffer among others). The bottom of every frame is used for output messages (then called 'echo area') and text input for commands (then called 'minibuffer').
In general, Emacs display elements (windows, frames, etc.) do not belong to any specific data or process. Buffers are not associated with windows, and multiple windows can be opened onto the same buffer, for example to track different parts of a long text side-by-side without scrolling back and forth, and multiple buffers can share the same text, for example to take advantage of different major modes in a mixed-language file. Similarly, Emacs instances are not associated with particular frames, and multiple frames can be opened displaying a single running Emacs process, e.g. a frame per screen in a multi-monitor setup, or a terminal frame connected via ssh from a remote system and a graphical frame displaying the same Emacs process via the local system's monitor. Just as buffers don't require windows, running Emacs processes do not require any frames, and one common usage pattern is to deploy Emacs as an editing server: running it as a headless daemon and connecting to it via a frame-spawning client. This server can then be made available in any situation where an editor is required, simply by declaring the client program to be the user's EDITOR or VISUAL variable. Such a server continues to run in the background, managing any child processes, accumulating stdin from open pipes, ports, or fifos, performing periodic or pre-programmed actions, remembering buffer undo history, saved text snippets, command history, and other user state between editing sessions. In this mode of operation, Emacs overlaps the functionality of programs like screen and tmux.
Because of this separation of display concerns from editing functionality, Emacs can display roughly similarly on any device more complex than a dumb terminal, including providing typical graphical WIMP elements on sufficiently featureful text terminals - though graphical frames are the preferred mode of display, providing a strict superset of the features of text terminal frames.
The first Emacs contained a help library that included documentation for every command, variable and internal function. Because of this, Emacs proponents described the software as self-documenting in that it presents the user with information on its normal features and its current state. Each function includes a documentation string that is displayed to the user on request, a practice that subsequently spread to programming languages including Lisp, Java, Perl, and Python. This help system can take users to the actual code for each function, whether from a built-in library or an added third-party library.
Emacs also has a built-in tutorial. Emacs displays instructions for performing simple editing commands and invoking the tutorial when it is launched with no file to edit. The tutorial is by Stuart Cracraft and Richard Stallman.
The Church of Emacs, formed by Richard Stallman, is a parody religion created for Emacs users.[50] While it refers to vi as the editor of the beast (vi-vi-vi being 6-6-6 in Roman numerals), it does not oppose the use of vi; rather, it calls it proprietary software anathema. ("Using a free version of vi is not a sin but a penance."[51]) The Church of Emacs has its own newsgroup, alt.religion.emacs,[52] that has posts purporting to support this parody religion. Supporters of vi have created an opposing Cult of vi.
Stallman has jokingly referred to himself as St I GNU cius, a saint in the Church of Emacs.[53]
There is folklore attributing a repetitive strain injury colloquially called Emacs pinky to Emacs' strong dependence on modifier keys,[54] although there have not been any studies done to show Emacs causes more such problems than other keyboard-heavy computer programs.
Users have addressed this through various approaches. Some users recommend simply using the two Control keys on typical PC keyboards like Shift keys while touch typing to avoid overly straining the left pinky, a proper use of the keyboard will reduce the RSI.[55] Software-side methods include:[56]
Hardware solutions include special keyboards such as Kinesis's Contoured Keyboard, which places the modifier keys where they can easily be operated by the thumb, or the Microsoft Natural keyboard, whose large modifier keys are placed symmetrically on both sides of the keyboard and can be pressed with the palm of the hand.[54] Foot pedals can also be used.
The Emacs pinky is a relatively recent development. The Space-cadet keyboard on which Emacs was developed had oversized Control keys that were adjacent to the space bar and were easy to reach with the thumb.[65]
The word emacs is sometimes pluralized as emacsen, by phonetic analogy with boxen and VAXen, referring to different varieties of Emacs.[66]



Information box
{'Original author(s)': 'David A. Moon\nGuy L. Steele Jr.\nRichard Stallman[1]', 'Developer(s)': 'Various free/libre software developers, including volunteers and commercial developers', 'Initial release': '1976; 47 years ago[2][3]', 'Written in': 'Lisp, C', 'Operating system': 'Cross-platform', 'Type': 'Text editor', 'Website': 'www.gnu.org/software/emacs/ '}