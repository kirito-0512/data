23628,
PDP-10,

Digital Equipment Corporation (DEC)'s PDP-10, later marketed as the DECsystem-10, is a mainframe computer family[1] manufactured beginning in 1966[2] and discontinued in 1983.[3][4][5] 1970s models and beyond were marketed under the DECsystem-10 name, especially as the TOPS-10 operating system became widely used.[a]
The PDP-10's architecture is almost identical to that of DEC's earlier PDP-6, sharing the same 36-bit word length and slightly extending the instruction set (but with improved hardware implementation). Some aspects of the instruction set are unusual, most notably the byte instructions, which operate on bit fields of any size from 1 to 36 bits inclusive, according to the general definition of a byte as a contiguous sequence of a fixed number of bits.
The PDP-10 was found in many university computing facilities and research labs during the 1970s, the most notable being Harvard University's Aiken Computation Laboratory, MIT's AI Lab and Project MAC, Stanford's SAIL, Computer Center Corporation (CCC), ETH (ZIR), and Carnegie Mellon University. Its main operating systems, TOPS-10 and TENEX, were used to build out the early ARPANET. For these reasons, the PDP-10 looms large in early hacker folklore.
Projects to extend the PDP-10 line were eclipsed by the success of the unrelated VAX superminicomputer, and the cancellation of the PDP-10 line was announced in 1983. According to reports, DEC sold "about 1500 DECsystem-10s by the end of 1980."[6]
The original PDP-10 processor is the KA10, introduced in 1968.[7] It uses discrete transistors packaged in DEC's Flip-Chip technology, with backplanes wire wrapped via a semi-automated manufacturing process.  Its cycle time is 1 μs and its add time 2.1 μs.[8] In 1973, the KA10 was replaced by the KI10, which uses transistor–transistor logic (TTL) SSI. This was joined in 1975 by the higher-performance KL10 (later faster variants), which is built from emitter-coupled logic (ECL), microprogrammed, and has cache memory. The KL10's performance was about 1 megaflops using 36-bit floating point numbers on matrix row reduction. It was slightly faster than the newer VAX-11/750, although more limited in memory.
A smaller, less expensive model, the KS10, was introduced in 1978, using TTL and Am2901 bit-slice components and including the PDP-11 Unibus to connect peripherals. The KS10 was marketed as the DECSYSTEM-2020, part of the DECSYSTEM-20 range; it was DEC's entry in the distributed processing arena, and it was introduced as "the world's lowest cost mainframe computer system."[9]
The KA10 has a maximum main memory capacity (both virtual and physical) of 256 kilowords (equivalent to 1152 kilobytes); the minimum main memory required is 16 kilowords. As supplied by DEC, it did not include paging hardware; memory management consists of two sets of protection and relocation registers, called base and bounds registers. This allows each half of a user's address space to be limited to a set section of main memory, designated by the base physical address and size. This allows the model of separate read-only shareable code segment (normally the high segment) and read-write data/stack segment (normally the low segment) used by TOPS-10  and later adopted by Unix. Some KA10 machines, first at MIT, and later at Bolt, Beranek and Newman (BBN), were modified to add virtual memory[10][11] and support for demand paging,[12][13] and more physical memory.
The KA10 weighs about 1,920 pounds (870 kg).[14]
The 10/50 was the top-of-the-line Uni-processor KA machine[15] at the time when the PA1050 software package was introduced. Two other KA10 models were the uniprocessor 10/40, and the dual-processor 10/55.[16][b]
The KI10 introduced support for paged memory management, and also support a larger physical address space of 4 megawords. KI10 models include 1060, 1070 and 1077, the latter incorporating two CPUs.
The original KL10 PDP-10 (also marketed as DECsystem-10) models (1080, 1088, etc.) use the original PDP-10 memory bus, with external memory modules. Module in this context meant a cabinet, dimensions roughly (WxHxD) 30 x 75 x 30 in. with a capacity of 32 to 256 kWords of magnetic-core memory. The processors used in the DECSYSTEM-20 (2040, 2050, 2060, 2065), commonly but incorrectly called "KL20", use internal memory, mounted in the same cabinet as the CPU. The 10xx models also have different packaging; they come in the original tall PDP-10 cabinets, rather than the short ones used later on for the DECSYSTEM-20.  The differences between the 10xx and 20xx models were primarily which operating system they ran, either TOPS-10 or TOPS-20. Apart from that, differences are more cosmetic than real; some 10xx systems have "20-style" internal memory and I/O, and some 20xx systems have "10-style" external memory and an I/O bus.  In particular, all ARPAnet TOPS-20 systems had an I/O bus because the AN20 IMP interface was an I/O bus device.  Both could run either TOPS-10 or TOPS-20 microcode and thus the corresponding operating system.
The later Model B version of the 2060 processors removes the 256 kiloword limit on the virtual address space by supporting up to 32 "sections" of up to 256 kilowords each, along with substantial changes to the instruction set.  The two versions are effectively different CPUs.  The first operating system that takes advantage of the Model B's capabilities is TOPS-20 release 3, and user mode extended addressing is offered in TOPS-20 release 4.  TOPS-20 versions after release 4.1 only run on a Model B.
TOPS-10 versions 7.02 and 7.03 also use extended addressing when run on a 1090 (or 1091) Model B processor running TOPS-20 microcode.
The final upgrade to the KL10 was the MCA25 upgrade of a 2060 to 2065 (or a 1091 to 1095), which gave some performance increases for programs which run in multiple sections.
The I/O architecture of the 20xx series KL machines is based on a DEC bus design called the Massbus. While many attributed the success of the PDP-11 to DEC's decision to make the PDP-11 Unibus an open architecture, DEC reverted to prior philosophy with the KL, making Massbus both unique and proprietary. Consequently, there were no aftermarket peripheral manufacturers who made devices for the Massbus, and DEC chose to price their own Massbus devices, notably the RP06 disk drive, at a substantial premium above comparable IBM-compatible devices. CompuServe for one, designed its own alternative disk controller that could operate on the Massbus, but connect to IBM style 3330 disk subsystems.
The KL class machines have a PDP-11/40 front-end processor for system start-up and monitoring. The PDP-11 is booted from a dual-ported RP06 disk drive (or alternatively from an 8" floppy disk drive or DECtape), and then commands can be given to the PDP-11 to start the main processor, which is typically booted from the same RP06 disk drive as the PDP-11. The PDP-11 performs watchdog functions once the main processor is running.
Communication with IBM mainframes, including Remote Job Entry (RJE), was accomplished via a DN61 or DN-64 front-end processor, using a PDP-11/40 or PDP-11/34a.[17][18]
The KS10 is a lower-cost PDP-10 built using AMD 2901 bit-slice chips, with an Intel 8080A microprocessor as a control processor.[19] The KS10 design was crippled to be a Model A even though most of the necessary data paths needed to support the Model B architecture are present.  This was no doubt intended to segment the market, but it greatly shortened the KS10's product life.
The KS system uses a similar boot procedure to the KL10. The 8080 control processor loads the microcode from an RM03, RM80, or RP06 disk or magnetic tape and then starts the main processor. The 8080 switches modes after the operating system boots and controls the console and remote diagnostic serial ports.
Two models of tape drives were supported by the TM10 Magnetic Tape Control subsystem:
A mix of up to eight of these could be supported, using seven-track or nine-track devices. The TU20 and TU30 each came in A (9-track) and B (7-track) versions, and all of the aforementioned tape drives could read/write from/to 200 BPI, 556 BPI and 800 BPI IBM-compatible tapes.
The TM10 Magtape controller was available in two submodels:
From the first PDP-6s to the KL-10 and KS-10, the user-mode instruction set architecture is largely the same. This section covers that architecture.  The only major change to the architecture is the addition of multi-section extended addressing in the KL-10; extended addressing, which changes the process of generating the effective address of an instruction, is briefly discussed at the end. Generally, the system has 36-bit words and instructions, and 18-bit addresses.
Note that the bit numbering order is different from some other DEC processors, and many newer processors.
There are 16 general-purpose, 36-bit registers.  The right half of these registers (other than register 0) may be used for indexing. A few instructions operate on pairs of registers. The "PC Word" register is split in half; the right 18-bits contains the program counter and the left 13-bits contains the processor status flags, with five zeros between the two sections. The condition register bits, which record the results of arithmetic operations (e.g. overflow), can be accessed by only a few instructions.
In the original KA-10 systems, these registers are simply the first 16 words of main memory. The "fast registers" hardware option implements them as registers in the CPU, still addressable as the first 16 words of memory. Some software takes advantage of this by using the registers as an instruction cache by loading code into the registers and then jumping to the appropriate address; this is used, for example, in Maclisp to implement one version of the garbage collector.[21] Later models all have registers in the CPU.
There are two operational modes, supervisor and user mode. Besides the difference in memory referencing described above, supervisor-mode programs can execute input/output operations.
Communication from user-mode to supervisor-mode is done through Unimplemented User Operations (UUOs): instructions which are not defined by the hardware, and are trapped by the supervisor. This mechanism is also used to emulate operations which may not have hardware implementations in cheaper models.
The major datatypes which are directly supported by the architecture are two's complement 36-bit integer arithmetic (including bitwise operations), 36-bit floating-point, and halfwords. Extended, 72-bit, floating point is supported through special instructions designed to be used in multi-instruction sequences. Byte pointers are supported by special instructions. A word structured as a "count" half and a "pointer" half facilitates the use of bounded regions of memory, notably stacks.
Instructions are stored in 36-bit words. There are two formats, general instructions and input/output instructions.[22]
In general instructions, the leftmost 9 bits, 0 to 8, contain an instruction opcode. Many of the possible 512 codes are not defined in the base model machines and are reserved for expansion like the addition of a hardware floating point unit. Following the opcode in bits 9 to 12 is the number of a register which will be used for the instruction. The input/output instructions all start with bits 0 through 3 being set to 1 (decimal value 7), bits 3 through 9 containing a device number, and 10 through 12 the instruction opcode.[22]
In both formats, bits 13 through 35 are used to form the "effective address", E. Bits 18 through 35 contain a numerical constant address, Y. This address may be modified by adding the 18-bit value in a register, X, the register number indicated in bits 14 to 17. If these are set to zero, no indexing is used, meaning register 0 cannot be used for indexing. Bit 13, I, indicates indirection, meaning the ultimate effective address used by the instruction is not E, but the address stored in memory location E. When using indirection, the data in word E is interpreted in the same way as the layout of the instruction; bits 0 to 12 are ignored, and 13 through 35 form I, X and Y as above.
Instruction execution begins by calculating E. It adds the contents of the given register X (if not 0) to the offset Y; then, if the indirect bit is 1, the value at E is fetched and the effective address calculation is repeated. If I is 1 in the stored value at E in memory, the system will then indirect through that address as well, possibly following many such steps.[22] This process continues until an indirect word with a zero indirect bit is reached. Indirection of this sort was a common feature of processor designs of this era.
In supervisor mode, addresses correspond directly to physical memory. In user mode, addresses are translated to physical memory. Earlier models give a user process a "high" and a "low" memory: addresses with a 0 top bit use one base register and those with a 1 use another. Each segment is contiguous.  Later architectures have paged memory access, allowing non-contiguous address spaces. The CPU's general-purpose registers can also be addressed as memory locations 0–15.
There are three main classes of general instructions: arithmetic, logical, and move; conditional jump; conditional skip (which may have side effects). There are also several smaller classes.
The arithmetic, logical, and move operations include variants which operate immediate-to-register, memory-to-register, register-to-memory, register-and-memory-to-both or memory-to-memory. Since registers may be addressed as part of memory, register-to-register operations are also defined. (Not all variants are useful, though they are well-defined.) For example, the ADD operation has as variants ADDI (add an 18-bit Immediate constant to a register), ADDM (add register contents to a Memory location), ADDB (add to Both, that is, add register contents to memory and also put the result in the register). A more elaborate example is HLROM (Half Left to Right, Ones to Memory), which takes the Left half of the register contents, places them in the Right half of the memory location, and replaces the left half of the memory location with Ones. Halfword instructions are also used for linked lists: HLRZ is the Lisp CAR operator; HRRZ is CDR.
The conditional jump operations examine register contents and jump to a given location depending on the result of the comparison. The mnemonics for these instructions all start with JUMP, JUMPA meaning "jump always" and JUMP meaning "jump never" – as a consequence of the symmetric design of the instruction set, it contains several no-ops such as JUMP. For example, JUMPN A,LOC jumps to the address LOC if the contents of register A is non-zero. There are also conditional jumps based on the processor's condition register using the JRST instruction. On the KA10 and KI10, JRST is faster than JUMPA, so the standard unconditional jump is JRST.
The conditional skip operations compare register and memory contents and skip the next instruction (which is often an unconditional jump) depending on the result of the comparison. A simple example is CAMN A,LOC which compares the contents of register A with the contents of location LOC and skips the next instruction if they are not equal.  A more elaborate example is TLCE A,LOC (read "Test Left Complement, skip if Equal"), which using the contents of LOC as a mask, selects the corresponding bits in the left half of register A. If all those bits are Equal to zero, skip the next instruction; and in any case, replace those bits by their boolean complement.
Some smaller instruction classes include the shift/rotate instructions and the procedure call instructions. Particularly notable are the stack instructions PUSH and POP, and the corresponding stack call instructions PUSHJ and POPJ. The byte instructions use a special format of indirect word to extract and store arbitrary-sized bit fields, possibly advancing a pointer to the next unit.[c]
The PDP-10 does not use memory-mapped devices, in contrast to the PDP-11 and later DEC machines. A separate set of instructions is used to move data to and from devices defined by a device number in the instruction. Bits 3 to 9 contain the device number, with the 7 bits allowing a total of 128 devices. Instructions allow for the movement of data to and from devices in word-at-a-time (DATAO and DATAI) or block-at-a-time (BLKO, BLKI).[23]
In block mode, the value pointed to by E is a word in memory that is split in two, the upper 18-bits (right half of the word) indicate a starting address in memory where the data is located (or written into) and the lower 18 bits are a counter. The block instructions increment both values every time they are called, thereby increasing the counter as well as moving to the next location in memory. It then performs a DATAO or DATAI. Finally, it checks the counter side of the value at E, if it is non-zero, it skips the next instruction. If it is zero, it performs the next instruction, normally a JUMP back to the top of the loop.[24] The BLK instructions are effectively small programs that loop over a DATA and increment instructions, but by having this implemented in the processor itself, it avoids the need to repeatedly read the series of instructions from main memory and thus performs the loop much more rapidly.[25]
The final set of I/O instructions are used to write and read condition codes on the device, CONO and CONI.[26] Additionally, CONSZ will perform a CONI, bitmask the retrieved data against the value in E, and then skip the next instruction if it is zero, used in a fashion similar to the BLK commands. Only the right 18 bits are tested in CONSZ.[27]
A second use of the CONO instruction is to set the device's priority level for interrupt handling. There are three bits in the CONO instruction, 33 through 35, allowing the device to be set to level 0 through 7. Level 1 is the highest, meaning that if two devices raise an interrupt at the same time, the lowest-numbered device will begin processing. Level 0 means "no interrupts", so a device set to level 0 will not stop the processor even if it does raise an interrupt.[28]
Each device channel has two memory locations associated with it, one at 40+2N and the other at 41+2N, where N is the channel number. Thus, channel 1 uses locations 42 and 43. When the interrupt is received and accepted, meaning no higher-priority interrupt is already running, the system stops at the next memory read part of the instruction cycle and instead begins processing at the address stored in the first of those two locations. It is up to the interrupt handler to turn off the interrupt level when it is complete, which it can do by running a CONO, DATA or BLK instruction.[28]
Two of the device numbers are set aside for special purposes. Device 0 is the computer's front-panel console; reading that device retrieves the settings of the panel switches while writing lights up the status lamps. Device 4 is the "priority interrupt", which can be read using CONI to gain additional information about an interrupt that has occurred.[29]
In processors supporting extended addressing, the address space is divided into "sections".  An 18-bit address is a "local address", containing an offset within a section, and a "global address" is 30 bits, divided into a 12-bit section number at the bottom of the upper 18 bits and an 18-bit offset within that section in the lower 18 bits.  A register can contain either a "local index", with an 18-bit unsigned displacement or local address in the lower 18 bits, or a "global index", with a 30-bit unsigned displacement or global address in the lower 30 bits.  An indirect word can either be a "local indirect word", with its uppermost bit set, the next 12 bits reserved, and the remaining bits being an indirect bit, a 4-bit register code, and an 18-bit displacement, or a "global indirect word", with its uppermost bit clear, the next bit being an indirect bit, the next 4 bits being a register code, and the remaining 30 bits being a displacement.[30]: 1-26–1-30 
The process of calculating the effective address generates a 12-bit section number and an 18-bit offset within that segment.[30]: 1-26–1-30 
The original PDP-10 operating system was simply called "Monitor", but was later renamed TOPS-10.  Eventually the PDP-10 system itself was renamed the DECsystem-10. Early versions of Monitor and TOPS-10 formed the basis of Stanford's WAITS operating system and the CompuServe time-sharing system.
Over time, some PDP-10 operators began running operating systems assembled from major components developed outside DEC. For example, the main Scheduler might come from one university, the Disk Service from another, and so on. The commercial timesharing services such as CompuServe, On-Line Systems, Inc. (OLS), and Rapidata maintained sophisticated inhouse systems programming groups so that they could modify the operating system as needed for their own businesses without being dependent on DEC or others. There are also strong user communities such as DECUS through which users can share software that they have developed.
BBN developed their own alternative operating system, TENEX, which fairly quickly became popular in the research community. DEC later ported TENEX to the KL10, enhanced it considerably, and named it TOPS-20, forming the DECSYSTEM-20 line.
MIT, which had developed CTSS, Compatible Time-Sharing System to run on their IBM 709 (and later a modified IBM 7094 system), also developed ITS, Incompatible Timesharing System[31] to run on their PDP-6 (and later a modified PDP-10);[32] the naming was related, since the IBM and the DEC/PDP hardware were different, i.e. "incompatible" (despite each having a 36-bit CPU). The ITS name, selected by Tom Knight, "was a play on" the CTSS name.[33]
Tymshare developed TYMCOM-X, derived from TOPS-10 but using a page-based file system like TOPS-20.[34]
DEC maintained DECsystem-10 FORTRAN IV (F40) for the PDP-10 from 1967-1975[35]
In 1971 to 1972, researchers at Xerox PARC were frustrated by top company management's refusal to let them buy a PDP-10. Xerox had just bought Scientific Data Systems (SDS) in 1969, and wanted PARC to use an SDS machine. Instead, a group led by Charles P. Thacker designed and constructed two PDP-10 clone systems named MAXC (pronounced as Max, in honour of Max Palevsky, who had sold SDS to Xerox) for their own use. MAXC was also a backronym for Multiple Access Xerox Computer. MAXC ran a modified version of TENEX.[36]
Third-party attempts to sell PDP-10 clones were relatively unsuccessful; see Foonly, Systems Concepts, and XKL.
One of the largest collections of DECsystem-10 architecture systems ever assembled was at CompuServe, which, at its peak, operated over 200 loosely coupled systems in three data centers in Columbus, Ohio. CompuServe used these systems as 'hosts', providing access to commercial applications, and the CompuServe Information Service. While the first such systems were bought from DEC, when DEC abandoned the PDP-10 architecture in favor of the VAX, CompuServe and other PDP-10 customers began buying plug compatible computers from Systems Concepts. As of January 2007[update], CompuServe was operating a small number of PDP-10 architecture machines to perform some billing and routing functions.
The main power supplies used in the KL-series machines were so inefficient that CompuServe engineers designed a replacement supply that used about half the energy. CompuServe offered to license the design for its KL supply to DEC for free if DEC would promise that any new KL bought by CompuServe would have the more efficient supply installed. DEC declined the offer.
Another modification made to the PDP-10 by CompuServe engineers was replacing the hundreds of incandescent indicator lamps on the KI10 processor cabinet with LED lamp modules. The cost of conversion was easily offset by cost savings in electricity use, reduced heat, and labor needed to replace burned-out lamps. Digital followed this step all over the world. The picture on the right hand side shows the light panel of the MF10 memory which is contemporary with the KI10 CPU. This item is part of a computer museum, and was populated with LEDs in 2008 for demonstration purposes only. There were no similar banks of indicator lamps on KL and KS processors themselves - only on legacy memory and peripheral devices.
The PDP-10 was eventually eclipsed by the VAX superminicomputer machines (descendants of the PDP-11) when DEC recognized that the PDP-10 and VAX product lines were competing with each other and decided to concentrate its software development effort on the more profitable VAX.  The PDP-10 product line cancellation was announced in 1983, including cancelling the ongoing Jupiter project to produce a new high-end PDP-10 processor (despite that project being in good shape at the time of the cancellation) and the Minnow project to produce a desktop PDP-10, which may then have been at the prototyping stage.[37]
This event spelled the doom of ITS and the technical cultures that had spawned the original jargon file, but by the 1990s it had become something of a badge of honor among old-time hackers to have cut one's teeth on a PDP-10.
The PDP-10 assembly language instructions LDB and DPB (load/deposit byte) live on as functions in the programming language Common Lisp. See the "References" section on the LISP article. The 36-bit word size of the PDP-6 and PDP-10 was influenced by the programming convenience of having 2 LISP pointers, each 18 bits, in one word.
Will Crowther created Adventure, the prototypical computer adventure game, for a PDP-10. Don Daglow created the first computer baseball game (1971) and Dungeon (1975), the first role-playing video game on a PDP-10. Walter Bright originally created Empire for the PDP-10. Roy Trubshaw and Richard Bartle created the first MUD on a PDP-10. Zork was written on the PDP-10. Infocom used PDP-10s for game development and testing.[38]
Bill Gates and Paul Allen originally wrote Altair BASIC using an Intel 8080 simulator running on a PDP-10 at Harvard University. Allen repurposed the PDP-10 assembler as a cross assembler for the 8080 chip.[39] They founded Microsoft shortly after.
The software for simulation of historical computers, SIMH, contains modules to emulate all the PDP-10 CPU models on a Windows or Unix-based machine. Copies of DEC's original distribution tapes are available as downloads from the Internet so that a running TOPS-10 or TOPS-20 system may be established. ITS and WAITS are also available for SIMH.[40][41]
Ken Harrenstien's KLH10 software for Unix-like systems emulates a KL10B processor with extended addressing and 4 MW of memory or a KS10 processor with 512 KW of memory. The KL10 emulation supports v.442 of the KL10 microcode, which enables it to run the final versions of both TOPS-10 and TOPS-20. The KS10 emulation supports both ITS v.262 microcode for the final version of KS10 ITS and DEC v.130 microcode for the final versions of KS TOPS-10 and TOPS-20.[42]
This article is based in part on the Jargon File, which is in the public domain.



Information box
{'Also known as': 'DECsystem-10', 'Developer': 'Digital Equipment Corporation', 'Product family': 'Programmed Data Processor', 'Type': 'Mainframe computer', 'Release date': '1966; 57 years ago', 'Discontinued': '1983; 40 years ago', 'Operating system': 'ITS, TOPS-10, TENEX, WAITS, CompuServe time-sharing system', 'Platform': 'DEC 36-bit', 'Predecessor': 'PDP-6', 'Related': 'DECSYSTEM-20'}