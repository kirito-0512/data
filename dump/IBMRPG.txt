25981,
IBMRPG,
RPG is a high-level programming language for business applications, introduced in 1959 for the IBM 1401. It is most well known as the primary programming language of IBM's midrange computer product line, including the IBM i operating system.[1] RPG has traditionally featured a number of distinctive concepts, such as the program cycle, and the column-oriented syntax.[2] The most recent version is RPG IV, which includes a number of modernization features, including free-form syntax.[3]
The RPG programming language originally was created by IBM for their 1401 systems. They also produced an implementation for the System/360, and it became the primary programming language for their midrange computer product line, (the System/3, System/32, System/34, System/38, System/36 and AS/400). There have also been implementations for DEC VAX, Sperry Univac BC/7, Univac system 80, Siemens BS2000, Burroughs B700, B1700, Hewlett Packard HP 3000, the ICL 2900 series, Honeywell 6220 and 2020, Four-Phase IV/70 and IV/90 series, Singer System 10 and WANG VS, as well as miscellaneous compilers and runtime environments for Unix-based systems, such as Infinite36 (formerly Unibol 36), and PCs (Baby/400, Lattice-RPG).
RPG II applications are still supported under the IBM z/VSE[4] and z/OS operating systems,[5] Unisys MCP,[6] Microsoft Windows[7] and OpenVMS.[8]
Originally developed by IBM in 1959, the name Report Program Generator was descriptive of the purpose of the language: generation of reports from data files.[9] FOLDOC accredits Wilf Hey with work at IBM that resulted in the development of RPG.[10] FARGO (Fourteen-o-one Automatic Report Generation Operation) was the predecessor to RPG on the IBM 1401.
Both languages were intended to facilitate ease of transition for IBM tabulating machine (Tab) unit record equipment technicians to the then-new computers. Tab machine technicians were accustomed to plugging wires into control panels to implement input, output, control and counter operations (add, subtract, multiply, divide).  Tab machines programs were executed by impulses emitted in a machine cycle; hence, FARGO and RPG emulated the notion of the machine cycle with the program cycle. RPG was superior to and rapidly replaced FARGO as the report generator program of choice.
The alternative languages generally available at the time were Assembler, COBOL or FORTRAN. Assembler and COBOL were more common in mainframe business operations (System/360 models 30 and above) and RPG more commonly used by customers who were in transition from tabulating equipment (System/360 model 20).
RPG II was introduced with the System/3 series of computers.  It was later used on System/32, System/34, and System/36, with an improved version of the language.  RPG II was also available for larger systems, including the IBM System/370 mainframe running DOS/VSE (then VSE/SP, VSE/ESA, and z/VSE). ICL also produced a version on its VME/K operating system.
In the early days of RPG, its major strength was the program cycle. A programmer would write code to process an individual record, and the program cycle would execute the change against every record of a file, taking care of the control flow. At that time each record (individual punched card) would be compared to each line in the program, which would act upon the record, or not, based upon whether that line had an "indicator" turned "on" or "off". The indicator consisted of a set of logical variables numbered 01–99 for user-defined purposes, or other smaller sets based upon record, field, or report processing functions. The concept of level breaks and matching records is unique to the RPG II language, and was originally developed with card readers in mind. The matching record feature of the cycle enabled easy processing of files having a header-to-detail relationship. RPG programs written to take advantage of the program cycle could produce complex reports with far fewer lines of computer code than programs written in COBOL and other business-centric languages.  
The program File Specifications, listed all files being written to, read from or updated, followed by Data Definition Specifications containing program elements such as Data Structures and dimensional arrays, much like a "Working-Storage" section of a COBOL program. This is followed by Calculation Specifications, which contain the executable instructions. Output Specifications can follow which can be used to determine the layout of other files or reports. Alternatively files, some data structures and reports can be defined externally, mostly eliminating the need to hand code input and output ("I/O") specifications.
RPG III was created for the System/38 and its successor the AS/400.  RPG III significantly departed from the original language, providing modern structured constructs like IF-ENDIF blocks, DO loops, and subroutines.  RPG III was also available for larger systems including the IBM System/370 mainframe running OS/VS1. It was also available from Unisys for the VS/9 operating system running on the UNIVAC Series 90 mainframes.
Since the introduction of the IBM System/38 in 1979 most RPG programmers discontinued use of the cycle in favor of controlling program flow with standard looping constructs, although IBM has continued to provide backward compatibility for the cycle.
DE/RPG or Data Entry RPG was exclusively available on the IBM 5280 series of data-entry workstations in the early '80s. It was similar to RPG III but lacking external Data Descriptions (DDS) to describe data(files) like on the System/38 and its successors. Instead, the DDS part had to be included into the RPG source itself.
RPG/400 was effectively RPG III running on AS/400. IBM renamed the RPG compiler as "RPG/400" but at the time of its introduction it was identical to the RPG III compiler on System/38. Virtually all IBM products were rebranded as xxx/400 and the RPG compiler was no exception. RPG III compiled with the RPG/400 compiler offered nothing new to the RPG III language until IBM began development of new operation codes, such as SCAN, CAT and XLATE after several years of AS/400 availability. These enhancements to RPG III were not available in the System/38 version of RPG III.
RPG IV, a.k.a. RPGLE [11]) was released in 1994 as part of the V3R2 release of OS/400 (now known as IBM i).[12]
[13]
With the release of RPG IV, the RPG name was officially no longer an initialism. RPG IV offered a greater variety of expressions within its Extended Factor-2 Calculation Specification and, later in life, its free-format Calculation Specifications and Procedure syntax.
RPG IV in the Integrated Language Environment framework in known at ILE RPG, and user guides explain the nuances of both.[14][15][16] RPG IV and ILE RPG are supported by IBM in the current IBM i platform.[17]
In 2001, with the release of OS/400 V5R1, RPG IV offered greater freedom for calculations than offered by the Extended Factor-2 Calculation Specification: a free-format text-capable source entry, as an alternative to the original column-dependent source format. The "/FREE" calculation did not require the operation code to be placed in a particular column; the operation code is optional for the EVAL and CALLP operations; and syntax generally more closely resembles that of mainstream, general-purpose programming languages. Until November 2013, the free format applied exclusively to the calculation specifications.[18] With the IBM i V7R1 TR7 upgrade to the language, the "/free" and "/end-free" calculations are no longer necessary, and the language has finally broken the ties to punched cards.
IBM Rational Developer for i (RDi),[19] an Eclipse-based Integrated Development Environment, is recommended by IBM for RPG development. RDi is part of IBM Rational Development Studio for i, a family of Integrated Language Environment (ILE) compilers.[20]
The Source Entry Utility (SEU) text editor is no longer recommended for RPG development, and development ceased after IBM i 6.1.[21] Other legacy developer tools include CODE/400 (based on IBM WorkFrame/2) and VisualAge for RPG.
IBM continues to enhance the RPG language[22] via software releases and intra-release “technology refreshes” (TRs).[23][24]  More built-in functions (BIFs) have been added.  It has the ability to link to Java objects,[25] and IBM i APIs; it can be used to write CGI programs with the help of IBM's Cgidev2 Web toolkit,[26] the RPG Toolbox, and other commercial Web-enabled packages. Even with the changes, it retains a great deal of backward compatibility, so an RPG program written 37 years ago could run today with little or no modification.
The SQL precompiler allows current RPG developers to take advantage of IBM's cost-based SQE (SQL Query Engine).  With the traditional F-Spec approach a developer had to identify a specific access path to a data set, now they can implement standard embedded SQL statements directly in the program.  When compiled, the SQL precompiler transforms SQL statements into RPG statements which call the database manager programs that ultimately implement the query request.
The RPG IV language is based on the EBCDIC character set, but also supports UTF-8, UTF-16 and many other character sets. The threadsafe aspects of the language are considered idiosyncratic by some as the compiler team has addressed threads by giving each thread its own static storage, rather than make the RPG run-time environment re-entrant. This has been noted to muddle the distinction between a thread and a process (making RPG IV threads a kind of hybrid between threads and processes).
In 2010, IBM launched RPG Open Access, also known as Rational Open Access: RPG Edition. It allows new I/O handlers to be defined by a programmer - enabling data to be read from and written to sources which RPG does not provide inbuilt support for.[27]
RPG supports the following data types.
Note:The character in the data type column is the character that is encoded on the Definition Specification in the column designated for data type.  To compare, in a language like C where definitions of variables are free-format and would use a keyword such as int to declare an integer variable, in RPG, a variable is defined with a fixed-format Definition Specification.  In the Definition Specification, denoted by a letter D in column 6 of a source line, the data type character would be encoded in column 40.  Also, if the data type character is omitted, that is, left blank, the default is A if no decimal positions are specified, P when decimal positions are specified for stand-along fields, and S (ZONED) when decimal positions are specified within a data structure.
The following program receives a customer number as an input parameter and returns the name and address as output parameters.
This is the most primitive version of RPG IV syntax. The same program is shown later with gradually more modern versions of the syntax and gradually more relaxed rules.
The same program using free calculations available starting in V5R1:
Assume the ARMSTF1 example table was created using the following SQL Statement:
The same program using free calculations and embedded SQL:
As of V7R1 of the operating system, the above program would not necessarily need the prototype in a separate file, so it could be completely written as:
Lastly, if you apply the compiler PTFs related Technology Refresh 7 (TR7) to your 7.1 operating system, then the above program can be coded completely in free-form, as follows:



Information box
{'Paradigm': 'Multi-paradigm', 'Developer': 'IBM', 'First appeared': '1959; 64 years ago', 'Stable release': 'RPG IV version 7 release 4 / October 6, 2020', 'Typing discipline': 'Strong, static', 'OS': 'CPF, SSP, OS/400, IBM i, OS/VS1, z/OS, DOS/VSE, VSE/SP, VSE/ESA, z/VSE, VS/9, PRIMOS, OpenVMS, Wang VS, Burroughs MCP, HP MPE, MS-DOS, OS/2, Microsoft Windows'}