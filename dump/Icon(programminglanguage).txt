14801,
Icon(programminglanguage),
Icon is a very high-level programming language based on the concept of "goal-directed execution" in which code returns a "success" along with valid values, or a "failure", indicating that there is no valid data to return. The success and failure of a given block of code is used to direct further processing, whereas conventional languages would typically use boolean logic written by the programmer to achieve the same ends. Because the logic for basic control structures is often implicit in Icon, common tasks can be completed with less explicit code.
Icon was designed by Ralph Griswold after leaving Bell Labs where he was a major contributor to the SNOBOL language. SNOBOL was a string-processing language with what would be considered dated syntax by the standards of the early 1970s. After moving to the University of Arizona, he further developed the underlying SNOBOL concepts in SL5, but considered the result to be a failure. This led to the significantly updated Icon, which blends the short but conceptually dense code of SNOBOL-like languages with the more familiar syntax of ALGOL-inspired languages like C or Pascal.
Like the languages that inspired it, the primary area of use of Icon is managing strings and textual patterns. String operations often fail, for instance, finding "the" in "world". In most languages, this requires testing and branching to avoid using a non-valid result. In Icon most of these sorts of tests are simply not required, reducing the amount of code written by the programmer. Complex pattern handling can be accomplished in a few lines of terse code, similar to more dedicated languages like Perl but retaining a more function-oriented syntax familiar to users of other ALGOL-like languages.
Icon is not object-oriented, but an object-oriented extension called Idol was developed in 1996 which eventually became Unicon. It also inspired other languages, with its simple generators being especially influential; Icon's generators were a major inspiration for the Python programming language.[2]
The original SNOBOL effort, retroactively known as SNOBOL1, launched in the fall of 1962 at the Bell Labs Programming Research Studies Department.[3] The effort was a reaction to the frustrations of attempting to use the SCL language for polynomial formula manipulation, symbolic integration and studying Markov chains. SCL, written by the department head Chester Lee, was both slow and had a low-level syntax that resulting in volumes of code for even simple projects. After briefly considering the COMIT language, Ivan Polonsky, Ralph Griswold and David Farber, all members of the six-person department, decided to write their own language to solve these problems.[4]
The first versions were running on the IBM 7090 in early 1963, and by the summer had been built out and was being used across Bell. This led almost immediately to SNOBOL2, which added a number of built-in functions, and the ability to link to external assembly language code. It was released in April 1964 and mostly used within Bell, but also saw some use at Project MAC. The introduction of system functions served mostly to indicate the need for user functions, which was the major feature of SNOBOL3, released in July 1964.[5]
SNOBOL3's introduction corresponded with major changes within the Bell Labs computing department, including the addition of the new GE 645 mainframe which would require a rewrite of SNOBOL. Instead, the team suggested writing a new version that would run on a virtual machine, named SIL for SNOBOL Intermediate Language, allowing it to be easily ported to any sufficiently powerful platform. This proposal was accepted as SNOBOL4 in September 1965. By this time, plans for a significantly improved version of the language emerged in August 1966.[6] Further work on the language continued throughout the rest of the 1960s, notably adding the associative array type in later version, which they referred to as a table.
Griswold left Bell Labs to become a professor at the University of Arizona in August 1971.[7] He introduced SNOBOL4 as a research tool at that time.[8]
As a language originally developed in the early 1960s, SNOBOL's syntax bears the marks of other early programming languages like FORTRAN and COBOL. In particular, the language is column-dependant, as many of these languages were entered on punch cards where column layout is natural. Additionally, control structures were almost entirely based on branching around code rather than the use of blocks, which were becoming a must-have feature after the introduction of ALGOL 60. By the time he moved to Arizona, the syntax of SNOBOL4 was hopelessly outdated.[9]
Griswold began the effort of implementing SNOBOL's underlying success/failure concept with traditional flow control structures like if/then. This became SL5, short for "SNOBOL Language 5", but the result was unsatisfying.[9] In 1977, he returned to the language to consider a new version. He abandoned the very powerful function system introduced in SL5 with a simpler concept of suspend/resume and developed a new concept for the natural successor to SNOBOL4 with the following principles;[9]
The new language was initially known as SNOBOL5, but as it was significantly different from SNOBOL in all but the underlying concept, a new name was ultimately desired. After considering "s" as a sort of homage to "C", but this was ultimately abandoned due to the problems with typesetting documents using that name. A series of new names were proposed and abandoned; Irving, bard, and "TL" for "The Language". It was at this time that Xerox PARC began publishing about their work on graphical user interfaces and the term "icon" began to enter the computer lexicon. The decision was made to change the name initially to "icon" before finally choosing "Icon".[9]
The Icon language is derived from the ALGOL-class of structured programming languages, and thus has syntax similar to C or Pascal. Icon is most similar to Pascal, using := syntax for assignments, the procedure keyword and similar syntax. On the other hand, Icon uses C-style braces for structuring execution groups, and programs start by running a procedure called main.[10]
In many ways Icon also shares features with most scripting languages (as well as SNOBOL and SL5, from which they were taken): variables do not have to be declared, types are cast automatically, and numbers can be converted to strings and back automatically.[11] Another feature common to many scripting languages, but not all, is the lack of a line-ending character; in Icon, lines that do not end with a semicolon get ended by an implied semicolon if it makes sense.[12]
Procedures are the basic building blocks of Icon programs. Although they use Pascal naming, they work more like C functions and can return values; there is no function keyword in Icon.[13]
One of the key concepts in SNOBOL was that its functions returned the "success" or "failure" as primitives of the language rather than using magic numbers or other techniques.[14][15] For instance, a function that returns the position of a substring within another string is a common routine found in most language runtime systems; in JavaScript one might want to find the position of the word "World" within "Hello, World!", which would be accomplished with position = "Hello, World".indexOf("World"), which would return 7. If one instead asks for the position = "Hello, World".indexOf("Goodbye") the code will "fail", as the search term does not appear in the string. In JavaScript, as in most languages, this will be indicated by returning a magic number, in this case -1.[16]
In SNOBOL a failure of this sort returns a special value, fail. SNOBOL's syntax operates directly on the success or failure of the operation, jumping to labelled sections of the code without having to write a separate test. For instance, the following code prints "Hello, world!" five times:[17]
To perform the loop, the less-than-or-equal operator, LE, is called on the index variable I, and if it Succeeds, meaning I is less than 5, it branches to the named label LOOP and continues.[17]
Icon retained the concept of flow control based on success or failure but developed the language further. One change was the replacement of the labelled GOTO-like branching with block-oriented structures in keeping with the structured programming style that was sweeping the computer industry in the late 1960s.[9] The second was to allow "failure" to be passed along the call chain so that entire blocks will succeed or fail as a whole. This is a key concept of the Icon language. Whereas in traditional languages one would have to include code to test the success or failure based on boolean logic and then branch based on the outcome, such tests and branches are inherent to Icon code and do not have to be explicitly written.[18]
For instance, consider this bit of code written in the Java programming language. It calls the function read() to read a character from a (previously opened) file, assigns the result to the variable a, and then writes the value of a to another file. The result is to copy one file to another. read will eventually run out of characters to read from the file, potentially on its very first call, which would leave a in an undetermined state and potentially cause write to cause a null pointer exception. To avoid this, read returns the special value EOF (end-of-file) in this situation, which requires an explicit test to avoid writeing it:
In contrast, in Icon the read() function returns a line of text or &fail. &fail is not simply an analog of EOF, as it is explicitly understood by the language to mean "stop processing" or "do the fail case" depending on the context. The equivalent code in Icon is:[15]
This means, "as long as read does not fail, call write, otherwise stop".[15] There is no need to specify a test against the magic number as in the Java example, this is implicit, and the resulting code is simplified. Because success and failure are passed up through the call chain, one can embed functions within others and they stop when the nested function fails. For instance, the code above can be reduced to:[19]
In this version, if read fails, write fails, and the while stops.[19] Icon's branching and looping constructs are all based on the success or failure of the code inside them, not on an arbitrary boolean test provided by the programmer. if performs the then block if its "test" returns a value, and the else block or moves to the next line if it returns &fail. Likewise, while continues calling its block until it receives a fail. Icon refers to this concept as goal-directed execution.[20]
It is important to contrast the concept of success and failure with the concept of an exception; exceptions are unusual situations, not expected outcomes. Fails in Icon are expected outcomes; reaching the end of a file is an expected situation and not an exception. Icon does not have exception handling in the traditional sense, although fail is often used in exception-like situations. For instance, if the file being read does not exist, read fails without a special situation being indicated.[15] In traditional language, these "other conditions" have no natural way of being indicated; additional magic numbers may be used, but more typically exception handling is used to "throw" a value. For instance, to handle a missing file in the Java code, one might see:
This case needs two comparisons: one for EOF and another for all other errors. Since Java does not allow exceptions to be compared as logic elements, as under Icon, the lengthy try/catch syntax must be used instead. Try blocks also impose a performance penalty even if no exception is thrown, a distributed cost that Icon normally avoids.
Icon uses this same goal-directed mechanism to perform traditional boolean tests, although with subtle differences. A simple comparison like if a < b then write("a is smaller than b") does not mean, "if the conditional expression evaluation results in or returns a true value" as they would under most languages; instead, it means something more like, "if the conditional expression, here < operation, succeeds and does not fail". In this case, the < operator succeeds if the comparison is true. The if calls its then clause if the expression succeeds, or the else or the next line if it fails. The result is similar to the traditional if/then seen in other languages, the if performs then if a is less than b. The subtlety is that the same comparison expression can be placed anywhere, for instance:
Another difference is that the < operator returns its second argument if it succeeds, which in this example will result in the value of b being written if it is larger than a, otherwise nothing is written. As this is not a test per se, but an operator that returns a value, they can be strung together allowing things like if a < b < c,[19] a common type of comparison that in most languages must be written as a conjunction of two inequalities like if (a < b) && (b < c).
A key aspect of goal-directed execution is that the program may have to rewind to an earlier state if a procedure fails, a task known as backtracking. For instance, consider code that sets a variable to a starting location and then performs operations that may change the value - this is common in string scanning operations for instance, which will advance a cursor through the string as it scans. If the procedure fails, it is important that any subsequent reads of that variable return the original state, not the state as it was being internally manipulated. For this task, Icon has the reversible assignment operator, <-, and the reversible exchange, <->. For instance, consider some code that is attempting to find a pattern string within a larger string:
This code begins by moving i to 10, the starting location for the search. However, if the find fails, the block will fail as a whole, which results in the value of i being left at 10 as an undesirable side effect. Replacing i := 10 with i <- 10 indicates that i should be reset to its previous value if the block fails. This provides an analog of atomicity in the execution.
Expressions in Icon may return a single value, for instance, 5 > x will evaluate and return x if the value of x is less than 5, or else fail. However, Icon also includes the concept of procedures that do not immediately return success or failure, and instead return new values every time they are called. These are known as generators, and are a key part of the Icon language. Within the parlance of Icon, the evaluation of an expression or function produces a result sequence. A result sequence contains all the possible values that can be generated by the expression or function. When the result sequence is exhausted, the expression or function fails.
Icon allows any procedure to return a single value or multiple values, controlled using the fail, return and suspend keywords. A procedure that lacks any of these keywords returns &fail, which occurs whenever execution runs to the end of a procedure. For instance:
Calling f(5) will return 1, but calling f(-1) will return &fail. This can lead to non-obvious behavior, for instance, write(f(-1)) will output nothing because f fails and suspends operation of write.[21]
Converting a procedure to be a generator uses the suspend keyword, which means "return this value, and when called again, start execution at this point". In this respect it is something like a combination of the static concept in C and return. For instance:[15]
creates a generator that returns a series of numbers starting at i and ending a j, and then returns &fail after that.[a] The suspend i stops execution and returns the value of i without reseting any of the state. When another call is made to the same function, execution picks up at that point with the previous values. In this case, that causes it to perform i +:= 1, loop back to the start of the while block, and then return the next value and suspend again. This continues until i <= j fails, at which point it exits the block and calls fail. This allows iterators to be constructed with ease.[15]
Another type of generator-builder is the alternator, which looks and operates like the boolean or operator. For instance:
This appears to say "if y is smaller than x or 5 then...", but is actually a short-form for a generator that returns values until it falls off the end of the list. The values of the list are "injected" into the operations, in this case, <. So in this example, the system first tests y < x, if x is indeed larger than y it returns the value of x, the test passes, and the value of y is written out in the then clause. However, if x is not larger than y it fails, and the alternator continues, performing y < 5. If that test passes, y is written. If y is smaller than neither x or 5, the alternator runs out of tests and fails, the if fails, and the write is not performed. Thus, the value of y will appear on the console if it is smaller than x or 5, thereby fulfilling the purpose of a boolean or. Functions will not be called unless evaluating their parameters succeeds, so this example can be shortened to:
Internally, the alternator is not simply an or and one can also use it to construct arbitrary lists of values. This can be used to iterate over arbitrary values, like:
As lists of integers are commonly found in many programming contexts, Icon also includes the to keyword to construct ad hoc integer generators:
which can be shortened:
Icon is not strongly typed, so the alternator lists can contain different types of items:
This writes 1, "hello" and maybe 5 depending on the value of x.
Likewise the conjunction operator, &, is used in a fashion similar to a boolean and operator:[22]
This code calls ItoJ and returns an initial value of 0 which is assigned to x. It then performs the right-hand side of the conjunction, and since x % 2 does equal 0, it writes out the value. It then calls the ItoJ generator again which assigns 1 to x, which fails the right-hand-side and prints nothing. The result is a list of every even integer from 0 to 10.[22]
The concept of generators is particularly useful and powerful when used with string operations, and is a major underlying basis for Icon's overall design. Consider the indexOf operation found in many languages; this function looks for one string within another and returns an index of its location, or a magic number if it is not found. For instance:
This will scan the string s, find the first occurrence of "the", and return that index, in this case 4. The string, however, contains two instances of the string "the", so to return the second example an alternate syntax is used:
This tells it to scan starting at location 5, so it will not match the first instance we found previously. However, there may not be a second instance of "the" -there may not be a first one either- so the return value from indexOf has to be checked against the magic number -1 which is used to indicate no matches. A complete routine that prints out the location of every instance is:
In Icon, the equivalent find is a generator, so the same results can be created with a single line:
Of course there are times where one does want to find a string after some point in input, for instance, if scanning a text file that contains a line number in the first four columns, a space, and then a line of text. Goal-directed execution can be used to skip over the line numbers:
The position will only be returned if "the" appears after position 5; the comparison will fail otherwise, pass the fail to write, and the write will not occur.
The every operator is similar to while, looping through every item returned by a generator and exiting on failure:[21]
There is a key difference between every and while; while re-evaluates the first result until it fails, whereas every fetches the next value from a generator. every actually injects values into the function in a fashion similar to blocks under Smalltalk. For instance, the above loop can be re-written this way:[21]
In this case, the values from i to j will be injected into someFunction and (potentially) write multiple lines of output.[21]
Icon includes several collection types including lists that can also be used as stacks and queues, tables (also known as maps or dictionaries in other languages), sets and others. Icon refers to these as structures. Collections are inherent generators and can be easily called using the bang syntax. For instance:
Using the fail propagation as seen in earlier examples, we can combine the tests and the loops:
Because the list collection is a generator, this can be further simplified with the bang syntax:
In this case, the bang in write causes Icon to return a line of text one by one from the array and finally fail at the end. &input is a generator-based analog of read that reads a line from standard input, so !&input continues reading lines until the file ends.
As Icon is typeless, lists can contain any different types of values:
The items can included other structures. To build larger lists, Icon includes the list generator; i := list(10, "word") generates a list containing 10 copies of "word". Like arrays in other languages, Icon allows items to be looked up by position, e.g., weight := aCat[4]. Array slicing is included, allowing new lists to be created out of the elements of other lists, for instance, aCat := Cats[2:4] produces a new list called aCat that contains "tabby" and 2002.
Tables are essentially lists with arbitrary index keys rather than integers:
This code creates a table that will use zero as the default value of any unknown key. It then adds two items into the table, with the keys "there" and "here", and values 1 and 2.
Sets are also similar to lists but contain only a single member of any given value. Icon includes the ++ to produce the union of two sets, ** the intersection, and -- the difference. Icon includes a number of pre-defined "Cset"s, a set containing various characters. There are four standard Csets in Icon, &ucase, &lcase, &letters, and &digits. New Csets can be made by enclosing a string in single quotes, for instance, vowel := 'aeiou'.
In Icon, strings are lists of characters. As a list, they are generators and can thus be iterated over using the bang syntax:
Will print out each character of the string on a separate line.
Substrings can be extracted from a string by using a range specification within brackets. A range specification can return a point to a single character, or a slice of the string. Strings can be indexed from either the right or the left. Positions within a string are defined to be between the characters 1A2B3C4 and can be specified from the right −3A−2B−1C0
For example,
Where the last example shows using a length instead of an ending position
The subscripting specification can be used as a lvalue within an expression. This can be used to insert strings into another string or delete parts of a string. For example:
A further simplification for handling strings is the scanning system, invoked with ?, which calls functions on a string:
Icon refers to the left-hand-side of the ? as the subject, and passes it into string functions. Recall the find takes two parameters, the search text as parameter one and the string to search within in parameter two. Using ? the second parameter is implicit and does not have to be specified by the programmer. In the common cases when multiple functions are being called on a single string in sequence, this style can significantly reduce the length of the resulting code and improve clarity. Icon function signatures identify the subject parameter in their definitions so the parameter can be hoisted in this fashion.
The ? is not simply a form of syntactic sugar, it also sets up a "string scanning environment" for any following string operations. This is based on two internal variables, &subject and &pos; &subject is simply a pointer to the original string, while &pos is the current position within it, or cursor. Icon's various string manipulation procedures use these two variables so they do not have to be explicitly supplied by the programmer. For example:
would produce:
Built-in and user-defined functions can be used to move around within the string being scanned. All of the built-in functions will default to &subject and &pos to allow the scanning syntax to be used. The following code will write all blank-delimited "words" in a string:
There are a number of new functions introduced in this example. pos returns the current value of &pos. It may not be immediately obvious why one would need this function and not simply use the value of &pos directly; the reason is that &pos is a variable and thus cannot take on the value &fail, which the procedure pos can. Thus pos provides a lightweight wrapper on &pos that allows Icon's goal-directed flow control to be easily used without having to provide hand-written boolean tests against &pos. In this case, the test is "is &pos zero", which, in the odd numbering of Icon's string locations, is the end of the line. If it is not zero, pos returns &fail, which is inverted with the not and the loop continues.
many finds one or more examples of the provided Cset parameter starting at the current &pos. In this case, it is looking for space characters, so the result of this function is the location of the first non-space character after &pos. tab moves &pos to that location, again with a potential &fail in case, for instance, many falls off the end of the string. upto is essentially the reverse of many; it returns the location immediately prior to its provided Cset, which the example then sets the &pos to with another tab. Alternation is used to also stop at the end of a line.
This example can be made more robust through the use of a more appropriate "word breaking" Cset which might include periods, commas and other punctuation, as well as other whitespace characters like tab and non-breaking spaces. That Cset can then be used in many and upto.
A more complex example demonstrates the integration of generators and string scanning within the language.
Laurence Tratt wrote a paper on Icon examining its real-world applications and pointing out a number of areas of concern. Among these were a number of practical decisions that derive from their origins in string processing but do not make as much sense in other areas.[21] Among them:
The decision to fail by default at the end of procedures makes sense in the context of generators, but less so in the case of general procedures. Returning to the example noted above, write(f(-1)) will not output which may be expected. However:[21]
will result in 10 being printed. This sort of issue is not at all obvious as even in an interactive debugger all the code is invoked yet x never picks up the expected value. This could be dismissed as one of those "gotchas" that programmers have to be aware of in any language, but Tratt examined a variety of Icon programs and found that the vast majority of procedures are not generators. This means that Icon's default behaviour is only used by a tiny minority of its constructs, yet represents a major source of potential errors in all the others.[21]
Another issue is the lack of a boolean data type[b] and conventional boolean logic. While the success/fail system works in most cases where the ultimate goal is to check a value, this can still lead to some odd behaviour in seemingly simple code:[22]
This program will print "taken". The reason is that the test, c, does return a value; that value is &null, the default value for all otherwise uninitiated variables.[23] &null is a valid value, so if c succeeds. To test this, one needs to make the test explicit, c === &null. Tratt supposed that it detracts from the self-documenting code, having supposed erroneously that it is testing "is c zero" or "does c exist".[22]



Information box
{'Paradigm': 'multi-paradigm: structured, text-oriented', 'Designed by': 'Ralph Griswold', 'First appeared': '1977; 46 years ago', 'Stable release': '9.5.20 / August 13, 2020; 2 years ago[1]', 'Typing discipline': 'dynamic', 'Website': 'www.cs.arizona.edu/icon'}